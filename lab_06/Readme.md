# Лабораторная работа №6. "Деревья, хеш –таблицы"
**Студент** Ларин Владимир - ИУ7-34Б


## Описание условия задачи

Построить ДДП, в вершинах которого находятся **слова** из текстового файла. Вывести его на экран в виде дерева. Сбалансировать полученное дерево и вывести его на экран.**Добавить** указанное слово, если его нет в дереве (по желанию пользователя) в исходное и сбалансированное дерево. Сравнить время добавления и объем памяти. Построить хеш-таблицу из слов текстового файла, задав размерность таблицы с экрана, используя **метод цепочек** для устранения коллизий.  Вывести  построенную  таблицу  слов  на  экран.  Осуществить **добавление** введенного слова, вывести таблицу. Сравнить время добавления, объем  памяти  и  количество  сравнений  при  использовании  ДДП, сбалансированных деревьев, хеш-таблиц и файла. 

## Техническое задание

### Входные данные:
0. Файл для построения деревьев
    - каждый новый элемент записан сновой строки
    - не пустой
    - имеет `LF` окончания строк 
1. Номер команды - целое число в диапазоне от `0` до `15` включительно.
2. Командно-зависимые данные:
    - строка - элемент дерева. Не нулевой.
    - тип хэш функции - чило из списка
        1. Сумма
        2. XOR сумма
        3. Хеширование Пирсона
        4. Хеширование DJB2
    - максимальное кол-во коллизий - число большее нуля
    - размерности таблицы - число большее нуля


### Выходные данные:
В зависимости от выбранного действия результатом работы программы могут являться:
1. Графическое представление
    - АВЛ дерева
    - ДДП
    - хэш-таблицы
2. Статистика по времени выполнения, объему занимаемой памяти и кол-ва сравнений при
    - добавлении элемента
    - при поиске
3. Информация о состоянии хэш таблицы
    - функция хэширования
    - максимальное кол-во коллизий
    - размерность таблицы
    - кол-во элементов в таблице


### Команды программы
- Перестроить деревья из файла
- ДДП
    - показать
    - добавить элемент
- АВЛ дерево
    - показать
    - добавить элемент
- Хеш-таблица
    - создать из файла
    - добавить элемент
    - показать
    - состояние
    - переструктурировать
        - самостоятельно
        - автоматически
- Все структуры
    - добавить элемент
    - поиск элемента
-  Анализ
    - добавления элемента
    - поиска элемента


### Обращение к программе:
Запускается из терминала при помощи комманды `./bin/app.out filename`, где `filename` - имя файла с данными.

### Аварийные ситуации:

1. Некорректный ввод номера команды.
    - **На входе**: число, большее, чем максмальный индекс команды или меньшее, чем минимальный. 
    - **На выходе**: Сообщение об ошибке
2. Ошибка открытия файла
    - **На входе**: отсутствие файла, запрещен доступ
    - **На выходе**: Сообщение об ошибке
3. Некорректный ввод типа хэш функции
    - **На входе**: ввод, отличный от указанного в ТЗ
    - **На выходе**: Сообщение об ошибке
4. Некорректный ввод строки - элемента дерева
    - **На входе**: ввод, отличный от указанного в ТЗ
    - **На выходе**: Сообщение об ошибке
5. Некорректный ввод максимальнго кол-ва коллизий 
    - **На входе**: ввод, отличный от указанного в ТЗ
    - **На выходе**: Сообщение об ошибке
6. Некорректный ввод размерности таблицы
    - **На входе**: ввод, отличный от указанного в ТЗ
    - **На выходе**: Сообщение об ошибке

## Структуры данных

### Двоичное дерево поиска

Для расширяемости структуры данных используются следующие алиасы.
```c
typedef char *btree_type_t; // Тип элементотв ДДП
typedef int (*btree_cmp_t)(btree_type_t, btree_type_t); // Компаратор для этого типа
```

Дескриптор ДДП

```c
typedef struct tree {
  btree_node_t *head; // Указатель на главный узел
  btree_cmp_t cmp; // Используемый компаратор
} btree_t;
```
Узел ДДП
```c
typedef struct btree_node {
  btree_type_t data; // Хранимые данные
  struct btree_node *left; // Указатель на левое поддерево
  struct btree_node *right; // Указатель на правое поддерево
} btree_node_t;
```

### АВЛ дерево

Для расширяемости структуры данных используются следующие алиасы.
```c
typedef char *avl_tree_type_t; // Тип элементов
typedef int (*avl_tree_cmp_t)(avl_tree_type_t, avl_tree_type_t); // Компаратор для этого типа
``` 
Узел АВЛ дерева

```c
typedef struct avl_tree_node {
  avl_tree_type_t data; // Хранимые данные
  struct avl_tree_node *left; // Указатель на левое поддерево
  struct avl_tree_node *right; // Указатель на правое поддерево
  size_t height; // Высота текущего поддерева
} avl_tree_node_t;
```
Дескриптор АВЛ дерева
```c
typedef struct avl_tree {
  avl_tree_node_t *head;  // Указатель на главный узел
  avl_tree_cmp_t cmp;  // Используемый компаратор
} avl_tree_t;
```


### Хэш таблица

Для расширяемости структуры данных используются следующие алиасы.
```c
typedef char *hash_type_t;  // Тип элементов 
typedef int (*hash_func_t)(hash_type_t); // Хэш-функция
typedef int (*hash_cmp_t)(hash_type_t, hash_type_t); // Компаратор для этого типа
```

Узел цепочки таблицы
```c
typedef struct hash_table_node {
  hash_type_t data;  // Хранимые данные
  struct hash_table_node *next;  // Указатель на следующий узел
} hash_table_node_t;
```
Дескриптор хэш-таблицы
```c
typedef struct hash_table {
  size_t max_collision_num; // Максимальное кол-во достигнутых коллизий
  size_t elements_count; // Кол-во элементов таблицы

  hash_func_t hasher; // Хэш функция
  hash_cmp_t cmp; // Компаратор

  hash_table_node_t **table; // Указатели на начало цепочек
  size_t table_size; // Размерность таблицы
} hash_table_t;
```


## Описание основных функций

### ДДП

- `btree_t *init_btree(btree_cmp_t cmp)` - Создание ДДП
- `void btree_free(btree_t *tree)` - Удаление ДДП
- `bool add_btree(btree_t *tree, btree_type_t element)` - добавление элемента
- `bool has_element_btree(btree_t *tree, btree_type_t element)` - поиск элемента

### АВЛ дерево

- `bool add_avl_tree(avl_tree_t *tree, avl_tree_type_t element)` - добавление элемента
- `avl_tree_t *init_avl_tree(avl_tree_cmp_t cmp)` - Создание АВЛ дерева
- `bool has_avl_tree(avl_tree_t *tree, avl_tree_type_t element)` - поиск элемента
- `avl_tree_node_t *rotate_left_avl_tree(avl_tree_node_t *node)` - Правый поворот
- `avl_tree_node_t *rotate_right_avl_tree(avl_tree_node_t *node)` - Левый поворот
- `void free_avl_tree(avl_tree_t *tree)` - Удаление АВЛ дерева

### Хэш-таблица

- `hash_table_t *init_hash_table(size_t, hash_func_t, hash_cmp_t);` - Создание хэш-таблицы
- `bool add_element_hash_table(hash_table_t *table, hash_type_t element);` - добавление элемента
- `bool has_element_hash_table(hash_table_t *table, hash_type_t element);` - поиск элемента
- `int restruct_hash_table(hash_table_t **, size_t new_table_size, hash_func_t);` - реструктуризация хэш таблицы
- `void free_hash_table(hash_table_t *table);` - Удаление хэш-таблицы

### Хэш функции

- `int hash_sum(char *str)` - хэш-функция суммы ASCI кодов символов строки 
- `int hash_xor(char *str)` - хэш-функция суммы операции логического или  ASCI кодов символов строки и случайного постоянного числа
- `int hash_pearson(char *str)` - 4-х байтная реализация [хэш-функции Пирсона](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%9F%D0%B8%D1%80%D1%81%D0%BE%D0%BD%D0%B0)


## Алгоритм

1. На экран пользователю выводится меню
2. Пользователь вводит номер команды
3. Выполняется действие согласно номеру команды

### ДДП
- поиск узла 
    - рекурсивно двигаться от корня в левое или правое поддерево в зависимости от значения ключа узла, пока не встретится нужный элемент
- включения  элемента  в  дерево
    - поиск корня  для  добавления  нового  узла
    - включение  узла  в левое или правое поддерев
### АВЛ дерево
- включения  элемента  в  дерево
    - поиск корня  для  добавления  нового  узла
    - включение  узла  в левое или правое поддерев
    - балансировка дерева
### Хэш таблица
- поиск элемента
    - вычисление хэша и переход к нужной цепочке
    - линейный поиск элемента в цепочке

## Тесты
```
  1) Перестроить деревья из файла
===== ДДП
  2) показать
  3) добавить элемент
===== АВЛ дерево
  4) показать
  5) добавить элемент
===== Хеш-таблица
  6) создать из файла
  7) добавить элемент
  8) показать
  9) состояние
======= переструктурировать
 10) самостоятельно
 11) автоматически
===== Все структуры
 12) добавить элемент
 13) поиск элемента
===== Анализ
 14) добавления элемента
 15) поиска элемента

  0) Выход 
```
1. Некорректный ввод номера команды.

|Ввод|Результат| Комментарий| 
|----|---|---|
|-1 | Сообщение об ошибке | |
|16 | Сообщение об ошибке | |
|ass| Сообщение об ошибке | |
2. Открытия файла

|Ввод|Результат| Комментарий| 
|----|---|---|
| $./bin/app.out| Сообщение об ошибке | |
| $./bin/app.out UNDEFINED_FILE| Сообщение об ошибке |Отсутствие файла |
| $./bin/app.out ./tests/abc.txt| Показ меню программы | Файл `./tests/abc.txt` существует |
3. Ввод типа хэш функции

|Ввод|Результат| Комментарий| 
|----|---|---|
| 6 `<enter>` 0| Сообщение об ошибке | 1. Сумма <br> 2. XOR сумма <br> 3. Хеширование Пирсона <br> 4. Хеширование DJB2|
| 6 `<enter>` 5| Сообщение об ошибке | |
| 6 `<enter>` m| Сообщение об ошибке | |
| 6 `<enter>` 1| Вопрос размерности таблицы | |
4. Ввод строки - элемента дерева

|Ввод|Результат| Комментарий| 
|----|---|---|
|5 `<enter>``<enter>`| Сообщение об ошибке | Пустой ввод |
|5 `<enter>`word`<enter>`| Сообщение о успешности операции | |
5. Ввод максимальнго кол-ва коллизий 

|Ввод|Результат| Комментарий| 
|----|---|---|
|6 `<enter>` 1 `<enter>` 11 `<enter>` -1 `<enter>`| Сообщение об ошибке |  |
|6 `<enter>` 1 `<enter>` 11 `<enter>` 0 `<enter>`| Сообщение об ошибке |  |
|6 `<enter>` 1 `<enter>` 11 `<enter>` m `<enter>`| Сообщение об ошибке |  |
|6 `<enter>` 1 `<enter>` 11 `<enter>` 5 `<enter>`| Сообщение о реструктуризации таблицы |  |
6. Ввод размерности таблицы

|Ввод|Результат| Комментарий| 
|----|---|---|
|6 `<enter>` 1 `<enter>` 0 `<enter>` -1| Сообщение об ошибке |  |
|6 `<enter>` 1 `<enter>` 11 `<enter>` 0 | Сообщение об ошибке |  |
|6 `<enter>` 1 `<enter>` 11 `<enter>` m | Сообщение об ошибке |  |
|6 `<enter>` 1 `<enter>` 11 `<enter>` 249 | Вопрос о кол-ве максимальных коллизий |  |
7. Анализ 

|Ввод|Результат| Комментарий| 
|----|---|---|
|14 | Открывается html таблица в браузере | |
|15 | Открывается html таблица в браузере | |

8. Граф. представление 

|Ввод|Результат| Комментарий| 
|----|---|---|
|2 | Открывается граф.представление ДДП | |
|4 | Открывается граф.представление АВЛ | |
|6 `<enter>` 3 `<enter>` 11 `<enter>` 5 `<enter>` 8  | Открывается граф.представление хэш-таблицы | |
|8  | Сообщение об отсутствии хэш таблицы | |


## Оценка эффективности

В таблицах приведены средние числа для 1000 повторений
### Добавление элемента
<table class='table table-bordered'> <thead> <tr><th rowspan=2>Размер СД </td><th colspan=3> Двоичное дерево поиска </td><th colspan=3> АВЛ дерево </td><th colspan=3> Хэш таблица </td></tr> <tr><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td></tr></thead><tbody><tr><th> 16 </th><td>0.177</td><td>4.250</td><td>400</td><td>0.282</td><td>8.250</td><td>528</td><td>0.183</td><td>1.625</td><td>408</td></tr><tr><th> 32 </th><td>0.150</td><td>5.500</td><td>784</td><td>0.266</td><td>11.250</td><td>1040</td><td>0.128</td><td>1.531</td><td>792</td></tr><tr><th> 64 </th><td>0.195</td><td>6.266</td><td>1552</td><td>0.387</td><td>14.578</td><td>2064</td><td>0.143</td><td>1.656</td><td>1544</td></tr><tr><th> 128 </th><td>0.265</td><td>7.641</td><td>3088</td><td>0.513</td><td>17.320</td><td>4112</td><td>0.198</td><td>2.297</td><td>2968</td></tr><tr><th> 256 </th><td>0.338</td><td>8.812</td><td>6160</td><td>0.596</td><td>20.262</td><td>8208</td><td>0.230</td><td>2.520</td><td>5928</td></tr><tr><th> 512 </th><td>0.324</td><td>10.072</td><td>12304</td><td>0.559</td><td>23.180</td><td>16400</td><td>0.219</td><td>3.797</td><td>11752</td></tr><tr><th> 1024 </th><td>0.375</td><td>11.496</td><td>24592</td><td>0.656</td><td>26.379</td><td>32784</td><td>0.279</td><td>5.929</td><td>23448</td></tr></tbody></table>
Из таблицы можно сделать выводы, что АВЛ дерево имеет самую низкую скорость вставки, это обусловлено процессом балансировки. В данной таблице видим, что самую высокую скорость генерации имеет хэш-таблица. 

### Поиск элемента
<table class='table table-bordered'> <thead> <tr><th rowspan=2>Размер СД </td><th colspan=3> Двоичное дерево поиска </td><th colspan=3> АВЛ дерево </td><th colspan=3> Хэш таблица </td><th colspan=3> Файл </td></tr> <tr><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td><td> Время, тики </td><td> Кол-во сравнений </td><td> Объём СД, Байты </td></tr></thead><tbody><tr><th> 16 </th><td>0.122</td><td>5.312</td><td>400</td><td>0.086</td><td>3.438</td><td>528</td><td>0.098</td><td>1.625</td><td>408</td><td>1.057</td><td>8.500</td><td>0</td></tr><tr><th> 32 </th><td>0.100</td><td>6.531</td><td>784</td><td>0.063</td><td>4.312</td><td>1040</td><td>0.068</td><td>1.531</td><td>792</td><td>1.118</td><td>16.500</td><td>0</td></tr><tr><th> 64 </th><td>0.106</td><td>7.281</td><td>1552</td><td>0.077</td><td>5.250</td><td>2064</td><td>0.061</td><td>1.656</td><td>1544</td><td>1.621</td><td>32.500</td><td>0</td></tr><tr><th> 128 </th><td>0.182</td><td>8.648</td><td>3088</td><td>0.134</td><td>6.281</td><td>4112</td><td>0.097</td><td>2.297</td><td>2968</td><td>2.853</td><td>64.500</td><td>0</td></tr><tr><th> 256 </th><td>0.198</td><td>9.816</td><td>6160</td><td>0.149</td><td>7.238</td><td>8208</td><td>0.094</td><td>2.520</td><td>5928</td><td>4.479</td><td>128.500</td><td>0</td></tr><tr><th> 512 </th><td>0.232</td><td>11.074</td><td>12304</td><td>0.169</td><td>8.244</td><td>16400</td><td>0.111</td><td>3.797</td><td>11752</td><td>8.428</td><td>256.500</td><td>0</td></tr><tr><th> 1024 </th><td>0.276</td><td>12.497</td><td>24592</td><td>0.198</td><td>9.296</td><td>32784</td><td>0.142</td><td>5.929</td><td>23448</td><td>18.258</td><td>512.500</td><td>0</td></tr></tbody></table>

Из таблицы мы можем сделать выводы, что последовательный поиск в файле имеет самую меньшую скорость (причем тестирование производилось на твердотельном диске). Следовательно, необходимо использовать АСД для поиска элементов. Лучше всего себя показала хэш-таблица, как по памяти, так и по скорости работы. 

> **Примечение:** Размерность хэш таблицы является наименьшим простым числом, которое больше числа `кол-во элементов * 0.85`



## Контрольные вопросы

1. Что такое дерево?
- Дерево   –   это   рекурсивная   структура   данных,   используемая   для представления иерархических связей, имеющих отношение «один ко многим».
2. Как выделяется память под представление деревьев?
- В виде связного списка — динамически под каждый узел.
3. Какие стандартные операции возможны над деревьями?
- Обход дерева
- поиск по дереву
- включение в дерево
- исключение из дерева.
4. Что такое дерево двоичного поиска?
- Двоичное дерево поиска - двоичное дерево, для каждого узла которого сохраняется условие:левый потомок больше родителю, правый потомок строго меньше родителя.
5. Чем отличается идеально сбалансированное дерево от АВЛ дерева?
- У АВЛ дерева для каждой его вершины высота двух её поддеревьев различается не более чем на 1, а у идеально сбалансированного дерева различается количество вершин в каждом поддереве не более чем на 1.
6. Чем отличается поиск в АВЛ-дереве от поиска в дереве двоичного поиска?
- Поиск в АВЛ дереве происходит быстрее, чем в ДДП, благодаря сбалансированности дерева.
7. Что такое хеш-таблица, каков принцип ее построения?
- Хеш-таблицей называется массив, заполненный элементами в порядке, определяемом хеш-функцией. Хеш-функция каждому элементу таблицы ставит в  соответствие   некоторый   индекс.  
8. Что такое коллизии? Каковы методы их устранения?
- Коллизия   –   ситуация,   когда   разным   ключам   хеш-функция   ставит   в соответствие один и тот же индекс. Основные методы устранения коллизий:
    - при открытом хешировании к ячейке поданному ключу прибавляется связанны список,
    - при закрытом – новый элемент кладется в ближайшую свободную ячейку после данной.
9. В каком случае поиск в хеш-таблицах становится неэффективен? 
Поиск в хеш-таблице становится неэффективен при большом числе коллизий –сложность поиска возрастает по сравнению с $`О(1)`$. В этом случае требуется реструктуризация таблицы – заполнение её с использованием новой хеш-функции или расширение таблицы. 
10. Эффективность поиска в АВЛ деревьях, в дереве двоичного поиска и в хеш-таблицах.
- В хеш-таблице минимальное время поиска $`О(1)`$.
- В АВЛ дереве: $`О(\log_2n)`$. 
- В ДДП $`О(h)`$, где $`h`$ - высота дерева (от $`\log_2n`$ до $`n`$).

## Вывод

В задачах связанных с быстром поиском случайных данных лучше всего подходит АСД Хэш-таблица с правильно подобранной хэш-функцией для данного типа данных. АВЛ дерево разумно использовать при большом кол-ве коллизий в хэш-таблице (т.е. если подобрать хэш-функцию не удалось).

